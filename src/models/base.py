"""
Base models for the Personal AI Assistant.

Provides common functionality for all Pydantic and SQLAlchemy models including
UUID generation, UTC timestamps, and shared validation logic.
"""

from datetime import datetime, timezone
from typing import Optional
from uuid import UUID, uuid4

from pydantic import BaseModel as PydanticBaseModel, Field, field_validator
from sqlalchemy import Column, DateTime, String, TypeDecorator
from sqlalchemy.ext.declarative import declarative_base


# SQLAlchemy declarative base for ORM models
Base = declarative_base()


class TZDateTime(TypeDecorator):
    """
    Custom SQLAlchemy type that ensures timezone awareness for SQLite.
    
    SQLite stores datetimes as strings and doesn't preserve timezone info.
    This decorator ensures that when reading from the database, we always
    return timezone-aware UTC datetimes.
    """
    impl = DateTime
    cache_ok = True

    def process_result_value(self, value: Optional[datetime], dialect) -> Optional[datetime]:
        """
        Convert naive datetime from database to timezone-aware UTC.
        
        Args:
            value: Datetime value from database (may be naive)
            dialect: SQLAlchemy dialect
            
        Returns:
            Timezone-aware datetime in UTC, or None if value is None
        """
        if value is not None and value.tzinfo is None:
            # Assume database values are in UTC and add timezone info
            return value.replace(tzinfo=timezone.utc)
        return value


def utc_now() -> datetime:
    """
    Get current UTC timestamp with timezone awareness.
    
    Returns:
        datetime: Current time in UTC with tzinfo set.
        
    Note:
        Always use this instead of datetime.utcnow() to ensure timezone awareness.
    """
    return datetime.now(timezone.utc)



class BaseTimestampModel(PydanticBaseModel):
    """
    Base Pydantic model with automatic timestamp handling.
    
    All models that need creation/update tracking should inherit from this.
    Timestamps are always in UTC with timezone awareness.
    """
    
    id: UUID = Field(default_factory=uuid4, description="Unique identifier")
    created_at: datetime = Field(
        default_factory=utc_now,
        description="Creation timestamp in UTC"
    )
    updated_at: datetime = Field(
        default_factory=utc_now,
        description="Last update timestamp in UTC"
    )
    
    @field_validator('created_at', 'updated_at')
    @classmethod
    def validate_timezone_aware(cls, v: datetime) -> datetime:
        """
        Ensure timestamps are timezone-aware (UTC).
        
        Raises:
            ValueError: If timestamp is naive (no timezone info).
        """
        if v.tzinfo is None:
            raise ValueError("Timestamps must be timezone-aware (UTC)")
        return v


    class Config:
        """Pydantic configuration."""
        from_attributes = True  # Allow ORM mode for SQLAlchemy integration
        json_encoders = {
            datetime: lambda v: v.isoformat(),
            UUID: lambda v: str(v)
        }


class BaseRequestModel(PydanticBaseModel):
    """
    Base model for API request bodies.
    
    Request models don't include id, created_at, or updated_at since these
    are auto-generated by the system. Use this for Create/Update operations.
    """
    
    class Config:
        """Pydantic configuration."""
        from_attributes = True
        json_encoders = {
            datetime: lambda v: v.isoformat(),
            UUID: lambda v: str(v)
        }


class BaseDBModel(Base):
    """
    Base SQLAlchemy model with common columns.
    
    All database tables should inherit from this to get automatic
    UUID primary keys and timestamp tracking.
    """
    
    __abstract__ = True  # Don't create a table for this base class

    
    id = Column(String(36), primary_key=True, default=lambda: str(uuid4()))
    created_at = Column(
        TZDateTime,
        nullable=False,
        default=utc_now
    )
    updated_at = Column(
        TZDateTime,
        nullable=False,
        default=utc_now,
        onupdate=utc_now
    )


def validate_content_length(content: str, max_length: int = 5000) -> str:
    """
    Validate content doesn't exceed maximum length.
    
    Args:
        content: Text content to validate
        max_length: Maximum allowed characters (default: 5000)
        
    Returns:
        str: The validated content
        
    Raises:
        ValueError: If content is empty or exceeds max_length
    """
    content = content.strip()
    if not content:
        raise ValueError("Content cannot be empty or whitespace-only")
    if len(content) > max_length:
        raise ValueError(
            f"Content exceeds maximum length of {max_length} characters "
            f"(got {len(content)})"
        )
    return content
